const mongodb = require("mongodb");
const mongoose = require("mongoose");

const { folderRepository } = require("./folder.model");

const ObjectId = mongoose.Types.ObjectId;

const PROJECTS = "projects";

const projectStatus = [
  "Active", 
  "Blocked", 
  "On Hold", 
  "Completed"
];

const ProjectSchema = new mongoose.Schema(
  {
    name: { 
      type: String, 
      required: true 
    },
    links: [new mongoose.Schema({
      url: { type: String, required: true} ,
      text: { type: String, required: true },
    })],
    status: { 
      type: String, 
      required: true, 
      enum: [...projectStatus] 
    },
    dueDate: { 
      type: Date,
      required: false,
      default: null, 
    },
    parentFolderIds: { 
      type: [ObjectId], 
      required: true 
    },
    todo: [new mongoose.Schema({
      title: { type: String, required: true },
      status: { type: String, required: true, enum: [...projectStatus] },
      details: { type: String, required: true },
      dueDate: { type: Date }
    })],
    userId: { 
      type: ObjectId, 
      indexed: true, 
      required: true 
    },
    isActive: { 
      type: Boolean, 
      default: false 
    },
    createdBy: { 
      type: ObjectId, 
      required: true 
    },
    // createdAt: generated by Mongo
    updatedBy: { 
      type: ObjectId, 
      required: true 
    }
    // updatedAt: generated by Mongo
  },
  { timestamps: true }
);

const projectSchema = mongoose.model(PROJECTS, ProjectSchema);

const projectRepository = {
  async createProject(project) {
    const doc = new projectSchema(project);
    return await doc.save();
  },

  async readManyProjects(userId, projectIdList) {
    return await projectSchema.find({ userId, _id: { $in: projectIdList } });
  },

  async readOneProject(userId, projectId) {
    if (!mongodb.ObjectID.isValid(projectId)) {
      return null;
    }
  
    return await projectSchema.findOne({ userId, _id: projectId });
  },

  async linkToParent(projectId, parentFolderId, userId) {
    const parentFolder = await folderRepository.readOneFolder(parentFolderId, userId);
    if (!parentFolder) {
      throw new Error(`Error linking to parent folder id=${parentFolderId}.  No such folder exists.`);
    }

    if (parentFolder.projectIds.findIndex(id => id === projectId) >= 0) {
      return true;
    }
  
    try {
      parentFolder.projectIds.push(projectId);
      parentFolder.updatedBy = userId;
      await parentFolder.save();
    } catch (err) {
      throw new Error(`Error linking to parent folder id=${parentFolder._id} name="${parentFolder.name}": ${err.message}`);
    }

    return true;
  },

  async unlinkFromParent(project, parentId, userId) {
    const parentFolder = await folderRepository.readOneFolder(parentId, userId);
    if (!parentFolder) {
      //console.log(`UNLINK: cannot find parent of project "${project.name}".  parentId=${project.parentId}`);
      return;
    }
  
    try {
      //console.log(`UNLINK: children before ${JSON.stringify(parentFolder.projectIds)}`);
      parentFolder.projectIds = parentFolder.projectIds.filter(id => id.toString() !== project._id.toString());
      await parentFolder.save();
      //console.log(`UNLINK: children after ${JSON.stringify(parentFolder.projectIds)}`);
    } catch (err) {
      throw Error(`Error unlinking from parent folder id=${parentFolder._id} name="${parentFolder.name}": ${err.message}`);
    }
  },

  async deleteAll(userId) {
    let result = await projectSchema.deleteMany({ userId });
  
    return (result && result.deletedCount) || 0;
  },

  async deleteMany(userId, projectIdList) {
    let result = await projectSchema.deleteMany({ userId, _id: { $in: projectIdList }});
  
    return (result && result.deletedCount) || 0;
  }
}

module.exports = {
  projectSchema,
  projectRepository
};
